{"version":3,"file":"js/215.4ca83620301a209dbd2f.js","mappings":"s5BAwGA,YAnGI,aAAc,gCAgCdA,SAAW,SAACC,GACR,OAAQA,GACJ,IAAK,UACD,4CAAqC,IAAIC,MAAOC,cAAcC,MAAM,KAAK,IAC7E,IAAK,kBACD,8CAAwC,EAAKC,OAAOC,IAApD,aAA4D,EAAKC,cAAcC,MACnF,IAAK,cACD,uCAAiC,EAAKD,cAAcC,MACxD,QACI,oCAA8B,EAAKD,cAAcC,QAzC/C,KA8CdC,WAAa,SAACC,EAAWT,EAAMU,GAC3B,GAAyB,mBAAdD,EACP,0EAAmEA,IAGvE,IAAK,EAAKE,MAAMC,SAASZ,GACrB,oBAAcA,EAAd,mBAGJ,IAAK,EAAKa,QAAQD,SAASF,GACvB,sBAAgBA,EAAhB,sBAxDM,KAqEdI,KArEc,mCAqEP,WAAOL,EAAWL,EAAQM,EAAQV,EAAMe,EAAkBC,GAA1D,sFACHD,EAAiB,EAAKE,cAAcC,OAEpC,EAAKV,WAAWC,EAAWT,EAAMU,GACjC,EAAKN,OAAOC,KAAMD,MAAAA,OAAA,EAAAA,EAAQe,KAAM,KAJ7B,kBAOyBV,EAAU,EAAD,SAC1BL,EAAOe,IAAM,CAAEA,GAAIf,EAAOe,KAC1Bf,GACA,EAAKE,eAHqB,IAI7Bc,YAAaV,KAXlB,uBAOOW,EAPP,EAOOA,QAPP,UAcgCA,EAdhC,iBAcaC,EAdb,EAcOC,KACFA,EAAkB,SAAXb,EAAoBc,KAAKC,UAAUH,GAAYA,GAE1DI,EAAAA,EAAAA,IAAaH,EAAM,EAAKxB,SAASC,GAAOU,GAExCM,IACAD,EAAiB,EAAKE,cAAcU,SApBrC,wDAsBCX,IACAD,EAAiB,EAAKE,cAAcW,SAvBrC,0EArEO,gEACVC,KAAKvB,cAAgB,CACjBN,KAAM,EACN8B,UAAWC,KAAKC,IAAIC,OAAOC,iBAAkB,kBAC7C3B,MAAM,IAAIN,MAAOC,cAAciC,QAAQ,QAAS,KAAKhC,MAAM,KAAK,GAAK,QAGzE0B,KAAKzB,OAAS,CACVC,IAAK,MAGTwB,KAAKlB,MAAQ,CAAC,kBAAmB,cAAe,OAAQ,eACxDkB,KAAKhB,QAAU,CAAC,MAAO,QAEvBgB,KAAKZ,cAAgB,CACjBC,MAAO,CACHkB,QAAS,OACTC,MAAOC,EAAAA,EAAAA,cAAmBC,EAAAA,EAAAA,kCAE9BZ,QAAS,CACLS,QAAS,UACTC,MAAOC,EAAAA,EAAAA,cAAmBC,EAAAA,EAAAA,oCAE9BX,QAAS,CACLQ,QAAS,SACTI,aAAa,EACbH,MAAOC,EAAAA,EAAAA,cAAmBC,EAAAA,EAAAA,wCAC1BE,YAAaH,EAAAA,EAAAA,cAAmBC,EAAAA,EAAAA","sources":["webpack:///./src/Helpers/DownloadReport.js"],"sourcesContent":["import { downloadFile } from '@redhat-cloud-services/frontend-components-utilities/helpers';\nimport { intl } from '../Utilities/IntlProvider';\nimport messages from '../Messages';\n\nclass DownloadReport {\n    constructor() {\n        this.defaultParams = {\n            page: 1,\n            page_size: Math.min(Number.MAX_SAFE_INTEGER, 9007199254740991),\n            date: new Date().toISOString().replace(/[T:]/g, '-').split('.')[0] + '-utc'\n        };\n\n        this.params = {\n            cve: null\n        };\n\n        this.pages = ['systems-exposed', 'system-cves', 'cves', 'system-list'];\n        this.formats = ['csv', 'json'];\n\n        this.notifications = {\n            start: {\n                variant: 'info',\n                title: intl.formatMessage(messages.notificationReportDownloadStart)\n            },\n            success: {\n                variant: 'success',\n                title: intl.formatMessage(messages.notificationReportDownloadSuccess)\n            },\n            failure: {\n                variant: 'danger',\n                autoDismiss: false,\n                title: intl.formatMessage(messages.notificationReportDownloadFailureTitle),\n                description: intl.formatMessage(messages.notificationReportDownloadFailureBody)\n            }\n        };\n    }\n\n    filename = (page) => {\n        switch (page) {\n            case 'reports':\n                return `vulnerability_cves-report--${new Date().toISOString().split('T')[0]}`;\n            case 'systems-exposed':\n                return `vulnerability_systems-exposed-${this.params.cve}--${this.defaultParams.date}`;\n            case 'system-list':\n                return `vulnerability_systems--${this.defaultParams.date}`;\n            default:\n                return `vulnerability_cves--${this.defaultParams.date}`;\n\n        }\n    };\n\n    checkTypes = (fetchData, page, format) => {\n        if (typeof fetchData !== 'function') {\n            throw `exec expects the 1st param to be funtion. Received ${typeof fetchData}`;\n        }\n\n        if (!this.pages.includes(page)) {\n            throw `Page ${page} does not exist`;\n        }\n\n        if (!this.formats.includes(format)) {\n            throw `Format ${format} is not supported`;\n        }\n    };\n\n    /**\n     * Execute and download the report\n     *\n     * @param {Function} fetchData - Function to be called in order to fetch data.\n     * @param {Object || Array} params - Object to be sent as request params. If you need to pass extra argument, pass an array.\n     * @param {String} format - Supported formats to download are CSV and JSON.\n     * @param {String} page - Name of the page based on which the filename will be determined.\n     * @returns {void}\n     */\n    exec = async (fetchData, params, format, page, showNotification, clearNotification) => {\n        showNotification(this.notifications.start);\n\n        this.checkTypes(fetchData, page, format);\n        this.params.cve = params?.id || null;\n\n        try {\n            let { payload } = await fetchData({\n                ...params.id && { id: params.id },\n                ...params,\n                ...this.defaultParams,\n                data_format: format\n            });\n\n            let { data: response } = await payload;\n            let data = format === 'json' ? JSON.stringify(response) : response;\n\n            downloadFile(data, this.filename(page), format);\n\n            clearNotification();\n            showNotification(this.notifications.success);\n        } catch (error) {\n            clearNotification();\n            showNotification(this.notifications.failure);\n\n            throw `${error}`;\n        }\n    };\n}\n\nexport default new DownloadReport();\n"],"names":["filename","page","Date","toISOString","split","params","cve","defaultParams","date","checkTypes","fetchData","format","pages","includes","formats","exec","showNotification","clearNotification","notifications","start","id","data_format","payload","response","data","JSON","stringify","downloadFile","success","failure","this","page_size","Math","min","Number","MAX_SAFE_INTEGER","replace","variant","title","intl","messages","autoDismiss","description"],"sourceRoot":""}